<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

    <div id="users"></div>

<script>

    // Деякі оператори:

    // ! - заперечення
    // !! - (заперечене заперечення) переведення до булівського типу
    // Все true, крім:
    const q = !!false;
    const r = !!0; // zero
    const s = !!''; // or "" (empty string)
    const t = !!null;
    const u = !!undefined;
    const v = !!NaN;

    const x = !!0;

    if (0) {
        console.log(10);
    }
        console.log(x); // false

    // JS Data Types:

    // 1. String
    // 2. Number
    // 3. Boolean
    // 4. undefined
    // 5. null
    // 6. Object
    // 7. Symbol
    // 8. BigInt (?)

    // Дані поділяються на прості та ссилочні:

    // 1. прості - primitive - всі, крім object 
    // 2. ссилочні - reference - object

    // копіювання:

    let a = 1;
    let b = a;

    b = 99;

    console.log(a, 'a'); // 1
    console.log(b, 'b'); // 99

    // мутація:

    const user = {
        name: 'Ivan',
        car: true,  // однорівнева вкладеність
        job: {
            title: 'Junior',
            paiment : 99999     // двохрівнева вкладеність
        }
    }

    // const userCopy = user;

    // Глибоке (багаторівневе) копіювання:
    
    const userCopy = JSON.parse(JSON.stringify(user));
    
    user.exp = 10;
    userCopy.wife = 'Nastya';

    console.log(user);
    console.log(userCopy);

    // якщо зробити копію об"єкта, то копіюється не сам об"єкт, 
    // а створюється лише посилання на нього (на відміну від примітивів, де створ.копія)
    // це мінус, тому повноцінну копію можна зробити за допомогою:
    // - деструктуризації або Object.assign(), якщо це однорівневе копіювання
    // - JSON або рекурсії, якщо це багаторівневе копіювання

    // Як вбити цикл

    let users = ['Alina', 'Ivan', 'Vova', 'Karina'];

    function find(arr=[]) {
        console.time('find')
        let valueToReturn;
        
        for (let i=0; i<arr.length; i++) {
            const name = arr[i];

            if (name.length>=5) {
                valueToReturn=name;
                break; // Kill the loop (впливає на цикл і switch case)
            }
        }

console.timeEnd('find')

        return valueToReturn;
        console.log('***********');
    }

let find1 = find(users);
console.log(find1);

// Як пропустити одну ітерацію

let users1 = ['Alina', 'Ivan', 'Vova', 'Dimasik', 'Karina'];

function find2(arr=[]) {
       
        let valueToReturn;
        
        for (let i=0; i<arr.length; i++) {
            const name = arr[i];

            if (name.toLowerCase().startsWith('a')){
                continue; // Skip one ineration
            }

            console.log(name);
            console.log('**************');
        }
    }

    let find3 = find2(users1);

    // Тернарні оператори (заміна if/else)

    let age = 22;

    if (age > 18) {
        console.log('Login')
    } else {
        console.log('NoWay')
    }

    age > 18 ? console.log('Login T') : console.log('NoWay T');

    let isUserAdult = age > 18 ? 'Yes' : 'No';

    // let isUserAdult = (age > 18 && age < 90) ? 'Yes' : 'No';
    // or
    // const isUserOld = age > 18 && age < 90;
    // let isUserAdult = isUserOld ? 'Yes' : 'No';
     
    console.log('isUserAdult');

    // Приклад використання РЕКУРСІЇ (функція, яка викликає сама себе)

    // Monday: { from: 10, to:21 }
    // Monday: { from: 9, to:20 }
    // W
    // T
    // F
    // Sat
    // Sun

    function recursion(arrToIterate = [], iterationIndex = 0) {

        if (iterationIndex >= arrToIterate.length) {
            return;
        }
        console.log(arrToIterate[iterationIndex]);

        recursion(arrToIterate, ++iterationIndex);
    }

    recursion(users); 

    // ДЕСТРУКТУРИЗАЦІЯ

    const newUser = {
        name: 'Victor',
        age: 25,
        car: 'Lacetti',
        bike: 'Yamaha',
        job: {
            title: "Middle"
        },
    }

    // const name = newUser.name;
    // const job = newUser.job;
    // const bike = newUser.bike;
    // ...  це не оптимізовано

    const name = 'Nastya'; // два однакові ключі => б"є помилку
    // щоб такого не було, під час деструктуризації можна переіменувати ключ

    const {name: userName, job, bike, wife = 'Karina', ...userV} = newUser;
        
    console.log(name); // Nastya
    console.log(userName); // Victor
    console.log(job);
    console.log(bike);
    console.log(userV);

    const newUsers = ['Alina', 'Ivan', 'Vova', 'Dimasik', 'Karina'];

    // const [, i, , d, k] = newUsers;

    // console.log(i, d, k); // Ivan Dimasik Karina

    // спредоператор

    const [, i, ...other] = newUsers;

    console.log(i);
    console.log(other);

    const userCope = {...newUser};

    userCope.name = 'Oleg';

    userCope.job.title = 'Senior';

    console.log(userCope);
    console.log(newUser);

    // REDUCE - метод масиву
    
    const prices = [10, 8, 1, 9, 20];

    let number = prices.reduce((acc, value) => {
        console.log(acc);
        console.log(value);
        console.log('*************');
        return acc + value;
    });

    console.log(number);

    const newPrices = [
        {item: 'cola', price: 10},
        {item: 'bread', price: 6},
        {item: 'beer', price: 15},
        {item: 'meat', price: 25},
        {item: 'candy', price: 10},
    ];

    let item = newPrices.reduce((acc, value) => {
        console.log(acc);
        console.log(value);
        console.log('*************');
        return acc + value.price; 
    }, 0);

    console.log(item);

    // методом REDUCE можна замінити два цикли: filter i map:

    // задача: з масиву цін вибрати ті, які більші/рівні за 15;
    // вставити їм в об"єкт марку expensive: true;
    // повернути лише їх

    const expensPrices = [
        {item: 'cola', price: 10},
        {item: 'bread', price: 6},
        {item: 'beer', price: 15},
        {item: 'meat', price: 25},
        {item: 'candy', price: 10},
];

let reduce = expensPrices.reduce((acc, value) => {
    if (value.price >= 15) {
        value.expensive = true;
        acc.push(value);
    }
    return acc;
}, []);

console.log(reduce);
console.log(expensPrices);

// fetch

const mainDiv = document.getElementById('users');

fetch('https://jsonplaceholder.typicode.com/users')
.then(value => value.json())
.then(value => {
    for (const user of value) {
        let userDiv = document.createElement('div');
        let detailsLink = document.createElement('a');

        userDiv.innerText = user.name;
        detailsLink.innerText = 'Get info';

        detailsLink.href = `user-d.html?user=${JSON.stringify(user)}`;

        userDiv.appendChild(detailsLink);
        mainDiv.appendChild(userDiv);
    }
});


</script>


</body>
</html>